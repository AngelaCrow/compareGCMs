{
    "contents" : "# Libraries, wd and data\n\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\npacman::p_load(magrittr, dplyr, dtplyr, raster, openxlsx, ccafs, rasterVis, maptools, shiny)\n\n\n\n####### The analysis is composed by 4 parts:\n# 1) Read the variables that will be analyzed on a list of raster stacks\n# 2) Filter and crop the variables to a set desired by the user (only a few bioclims, extent of your study - area)\n# 3) Calculate Ensembles and compare each model with them\n\n\n####################\n# First, set some PARAMETERS of the models you want to compare and the study area\nyear <- c(\"2050\", \"2070\")    # from a list with 2050, 2070\nrcp <- c(\"RCP 4.5\", \"RCP 8.5\")   # from a list with \"RCP 2.6\", \"RCP 4.5\", \"RCP 6.0\", \"RCP 8.5\"\n\n# USER EXTENT\n# a. Define the extent directly\nmy.extent <- extent(-120, -31, -57, 33)\n\n# b. Choose it with drawExtent\nplot(vars[[1]][[1]][[1]][[1]]) # Make a plot of one of the variables to help the drawing\nmy.extent <- drawExtent()\n\n# c. Take it from a country name\ncountry <- \"Argentina\"\nif (class(my.extent) == \"character\"){\n  data(wrld_simpl)\n  my.extent <- wrld_simpl[wrld_simpl$NAME %in% country,] %>%\n    extent\n}\n####################\n\n\n### 1) Read the variables that will be analyzed on a list of raster stacks\n\n# There are 3 options: \n# a) download variables form worldclim\n# b) download variables form CCAFS (more complite, sometimes the server is down)\n# c) Make you own stacks of variables (see at the end of this section how to organize them on a list)\n\n### a) Download from WorldClim\nrcp.equiv <- data.frame(name = c(\"RCP 2.6\", \"RCP 4.5\", \"RCP 6.0\", \"RCP 8.5\"), cod = c(26, 45, 60, 85))\nyear.equiv <- data.frame(name = c(\"2050\", \"2070\"), cod = c(50, 70))\n\n#all.models <- c(\"AC\", \"BC\", \"CC\", \"CE\", \"CN\", \"GF\", \"GD\", \"GS\", \"HD\", \"HG\", \"HE\", \"IN\", \"IP\", \"MI\", \"MR\", \"MC\", \"MP\", \"MG\", \"NO\")\n\nall.models <- c(\"AC\", \"BC\")\n\nyear <- c(\"2050\")    # from a list with 2050, 2070\nrcp <- c(\"RCP 4.5\", \"RCP 8.5\")\n\n\nvars <- list()\nfor (a in year){\n  wc.vars.temp3 <- list()\n  for (x in rcp){\n    wc.vars.temp2 <- list()\n    for (m in all.models){\n      rm(wc.vars.temp)\n      wc.vars.temp <- try(getData(\"CMIP5\", var=\"bio\", res=10, rcp=rcp.equiv$cod[rcp.equiv$name == x], year=year.equiv$cod[year.equiv$name == a], model=m))\n      if (!is.null(wc.vars.temp)){\n        if (!inherits(wc.vars.temp, \"try-error\")){     # Some of the combinations are not available, don't stop if you try to download an unexisting combination\n          names(wc.vars.temp) <- paste0(\"bio_\", 1:19)\n          wc.vars.temp2[[length(wc.vars.temp2)+1]] <- wc.vars.temp\n          names(wc.vars.temp2)[[length(wc.vars.temp2)]] <- m\n        }\n      }\n    }\n    wc.vars.temp3[[length(wc.vars.temp3)+1]] <- wc.vars.temp2\n    names(wc.vars.temp3)[[length(wc.vars.temp3)]] <- x\n  }\n  vars[[length(vars)+1]] <- wc.vars.temp3\n  names(vars)[[length(wc.vars)]] <- a\n}\n\n\n\n### b) Download variable rasters from CCAFS\n# Table of correspondence between parameters and CCAFS ids\nrcp.equiv <- data.frame(name = c(\"RCP 2.6\", \"RCP 4.5\", \"RCP 6.0\", \"RCP 8.5\"), cod = 7:10)\nyear.equiv <- data.frame(name = c(\"2050\", \"2070\"), cod = c(6, 8))\n\n# Find URLs with download links (Parameter options with ?'ccafs-search')\ncc.query <- list()\nfor (a in 1:length(year)){\n  for (x in 1:length(rcp)){\n    cc.query.temp <- cc_search(file_set = 12,\n                               scenario = rcp.equiv$cod[rcp.equiv$name == rcp[x]],    # 7:rcp26 ; 8:rcp45 ; 9:rcp60 ; 10:rcp85\n                               # model = 2,     # Here you can choose along GCMs, blank will return all available\n                               extent = \"global\", \n                               format = \"ascii\", \n                               period = year.equiv$cod[year.equiv$name == rcp[a]],       #5:2040 ; 6:2050 ; 7:2060 ; 8:2070\n                               variable = 1,     # 1:bioclimatic\n                               resolution = 4    # 4:10min\n    )# %>% print\n    cc.query[length(cc.query)+1] <- list(cc.query.temp)\n    names(cc.query)[[x]] <- rcp[x]\n  }\n}\n\n# Download the variables in those URL and read them as raster stacks\n# Store all them in the list \"vars\"\nvars <- list()\nfor (x in 1:length(cc.query)){\n  vars.temp <- lapply(cc.query[[x]][1:length(cc.query[[x]])], cc_data_fetch, progress = TRUE) %>%\n    lapply(cc_data_read)\n  \n  # Change the index of each element in the list by the GCM name\n  splitted.url <- strsplit(cc.query[[x]], \"/\")\n  for (u in 1:length(splitted.url)){\n    long <- splitted.url[u][[1]] %>%\n      tail(n=1)\n    short <- strsplit(long, \"_rcp\")[[1]] %>%\n      head(n=1)\n    names(vars.temp)[[u]] <- short\n  }\n  \n  vars[[x]] <- vars.temp\n  names(vars)[[x]] <- rcp[x]\n}   \n\n\n### c) Alternativelly, the variables could be read from raster files locally.\n## For the rest of the script to work straightforward, keep in mind that they should be organized as follows:\n## A list, with an element for each year\n## Each year in the list, should contain an element for each RCP\n## Each RCP should contain stacks of each GCM bioclimatic variables (e.g: a stack for bnu_esm containing bio_1:bio_19), year and rcp given by its position on the list\n\n###############################################\n\n### 2) Filter the variables to a set desired by the user\n\n## a) Select only some of the bioclimatic variables\nselected.bio <- c(1:5, 12:13)\n\n# Filter selected bios across all the layers\nvars.2 <- vars\nfor(y in 1:length(vars.2)){   # year\n  for (r in 1:length(vars.2[[y]])){   # rcp\n    for (g in 1:length(vars.2[[y]][[r]])){   # gcm\n      vars.2[[y]][[r]][[g]] <- subset(vars.2[[y]][[r]][[g]], subset=paste0(\"bio_\", selected.bio))\n    }\n  }\n}\n\n\n\n## b) Crop variables to a user-defined Extent\n\n## cut the variables to the extent if a user-extent is available \n## (this could be done after bioclim variables have been selected. It would be faster, but not all variables would be ready for an eventual selection later\nif (exists(\"my.extent\")){\n  vars.3 <- vars.2\n  for(y in 1:length(vars.3)){\n    for (r in 1:length(vars.3[[y]])){\n      for (g in 1:length(vars.3[[y]][[r]])){\n        vars.3[[y]][[r]][[g]] <- crop(vars.3[[y]][[r]][[g]], my.extent)\n      }\n    }\n  }\n}\n\n\n###############################################\n\n### 3) Calculate Ensembles and compare each model with them\n## a) Calculate ensembles\n\nensembles <- vars.3    # Ensembles will be stored in this object\n\nfor (y in 1:length(vars.3)){        # year\n  for (r in 1:length(vars.3[[y]])){        # rcp\n    bio.sub.ensemble <- stack()\n    for (b in 1:length(selected.bio)){         # for every bio-variable\n      gcm.sub.ensemble <- stack()\n      for (g in 1:length(vars.3[[y]][[r]])){      # across gcms\n        gcm.sub.ensemble <- stack(gcm.sub.ensemble, vars.3[[y]][[r]][[g]][[b]])   \n      }\n      # Calculate the mean across gcms\n      bio.sub.ensemble <- stack(bio.sub.ensemble, mean(gcm.sub.ensemble) %>% setNames(paste0(\"bio_\", selected.bio[b])))\n    }\n    ensembles[[y]][[r]] <- bio.sub.ensemble    # and store it in \"ensembles\"\n  }\n}\n\n## b) Compare each GCM variable with the ensemble\n# Create a table to store all the comparisons\n\ncomp.table <- data.frame(year = character(), rcp = character(), gcm = character())\ncomp.table$year <- as.character(comp.table$year); comp.table$rcp <- as.character(comp.table$rcp); comp.table$gcm <- as.character(comp.table$gcm)\nfor (b in selected.bio){\n  comp.table$newcol <- numeric(nrow(comp.table))\n  names(comp.table)[ncol(comp.table)] <- paste0(\"bio_\", b)\n}\ncomp.table.template <- comp.table\n\n# Loop throw all bioclims of each GCM in each scenario and compare it to the correspondent ensemble\nfor(y in 1:length(ensembles)){\n  for (r in 1:length(ensembles[[y]])){\n    for (g in 1:length(vars.3[[y]][[r]])){\n      comp.table.temp <- comp.table.template\n      comp.table.temp[nrow(comp.table.temp)+1,1] <- names(ensembles)[[y]]    # these lines prepare the data for the gcm info to bind to the table\n      comp.table.temp[nrow(comp.table.temp),2] <- names(ensembles[[y]])[[r]]\n      comp.table.temp[nrow(comp.table.temp),3] <- names(vars.3[[y]][[r]])[[g]]\n      res <- cellStats(abs(vars.3[[y]][[r]][[g]] - ensembles[[y]][[r]]), stat=\"sum\", na.rm=TRUE)  # Calculate the sum of the differences (in absolute value)\n      comp.table.temp[nrow(comp.table.temp), 4:(3+length(res))] <- res\n      comp.table <- rbind(comp.table, comp.table.temp)\n    }\n  }\n}  \n\n### Normalize the results, so different variables can be compared among them\n# Function\nnormalizeMinMax <- function(x, newMin, newMax){ (x - min(x, na.rm=T))/(max(x, na.rm=T)-min(x, na.rm=T)) * (newMax - newMin) + newMin }\n\ncomp.table.norm <- comp.table\n\nfor (y in unique(comp.table.norm$year)){\n  for (r in unique(comp.table.norm$rcp)){\n    for (b in grep(\"bio\", names(comp.table.norm))){\n      sc.values <- comp.table.norm[(comp.table.norm$year == y & comp.table.norm$rcp == r),b]\n      norm.values <- normalizeMinMax(sc.values, 0, 1)\n      comp.table.norm[(comp.table.norm$year == y & comp.table.norm$rcp == r),b] <- norm.values\n    }\n  }\n}\n\n\n### Summarize the result: The final TOTAL column summarizes how similar is, in average, the layer to the ensemble\n# The closest to 0 it is, the more similar\nfor (row in 1:nrow(comp.table.norm)){\n  comp.table.norm$total[row] <- mean(as.numeric(comp.table.norm[row, grep(\"bio\", names(comp.table.norm))]), na.rm=T)\n}\nprint(comp.table.norm)\n\n\n",
    "created" : 1490804278253.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3142611909",
    "id" : "A3017D19",
    "lastKnownWriteTime" : 1490867194,
    "path" : "~/Documents/GcModels/Compare_GCMs_completeWorkflow.R",
    "project_path" : "Compare_GCMs_completeWorkflow.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}